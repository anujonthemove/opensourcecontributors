#!/usr/bin/env python3
# Works only for archives from 2015-01-01 -> Present
import os
import os.path
import sys
import csv
import json
import itertools
import gzip
import glob
import fileinput
import urllib.parse
import dateutil.parser
from pprint import pprint
from datetime import datetime
from datetime import timezone

GITHUB_ARCHIVE_EVENT_PATH = os.getenv("GITHUB_ARCHIVE_EVENT") or os.path.expanduser('~/github-archive')
GITHUB_ARCHIVE_TIMELINE_PATH = os.getenv("GITHUB_ARCHIVE_TIMELINE") or os.path.expanduser('~/github-archive-timeline')

class Event(object):
    types = dict()

    def __init__(self, raw_event, source_fmt):
        makers = {
            'event': (self.make_common_from_event, self.make_from_event),
            'timeline': (self.make_common_from_timeline, self.make_from_timeline)
        }
        maker = makers.get(source_fmt, None)
        if maker is None:
            raise "source_fmt should either be 'event' (json) or 'timeline' (csv)"
        for m in maker:
            m(raw_event)

    def make_common_from_event(self, raw_event):
        self.type = raw_event['type']
        self._event_id = raw_event['id']
        self.created_at = dateutil.parser.parse(raw_event['created_at']).isoformat()

        if 'actor' in raw_event:
            self.user = raw_event['actor']['login']
            self._user_lower = self.user.lower()
        if 'repo' in raw_event:
            self.repo = raw_event['repo']['name']
            self._repo_lower = self.repo.lower()
        if 'org' in raw_event:
            self.org = raw_event['org']['login']
            self._org_lower = self.org.lower()

    def make_common_from_timeline(self, raw_event):
        self.type = raw_event['type']
        created_at = datetime.strptime(raw_event['created_at'],
                                       '%Y-%m-%d %H:%M:%S')
        created_at = created_at.replace(tzinfo=timezone.utc)
        self.created_at = created_at.isoformat()
        self.user = raw_event['actor']
        self._user_lower = self.user.lower()
        self.repo = "{}/{}".format(raw_event['repository_owner'],
                                   raw_event['repository_name'])
        self._repo_lower = self.repo.lower()
        self.org = raw_event['repository_organization']
        self._org_lower = self.org.lower()

    def make_from_event(self, raw_event):
        """
        From new API, natively JSON (on/after 2015-01-01)
        """
        raise "{} must override make_from_event".format(self.__class__.__name__)

    def make_from_timeline(self, row):
        """
        From old API (before 2015-01-01)
        """
        raise "{} must override make_from_timeline".format(self.__class__.__name__)

    @classmethod
    def register_event(cls, event_cls):
        cls.types[event_cls.__name__] = event_cls
        return event_cls

    @classmethod
    def from_raw(cls, raw_event, source_fmt):
        """
        Factory method to create appropriate event instance from raw JSON data
        """
        subclass = cls.types.get(raw_event['type'], None)
        if subclass is None:
            return None
        return subclass(raw_event, source_fmt)


register_event = Event.register_event

@register_event
class GollumEvent(Event):
    def make_from_event(self, d):
        self.pages = d['payload']['pages']

    def make_from_timeline(self, d):
        self.pages = [{
            'html_url': d["payload_page_html_url"],
            'summary': d["payload_page_summary"],
            'page_name': d["payload_page_page_name"],
            'action': d["payload_page_action"],
            'title': d["payload_page_title"],
            'sha': d["payload_page_sha"]
        }]


@register_event
class IssuesEvent(Event):
    def make_from_event(self, d):
        self.action = d['payload']['action']
        issue = d['payload']['issue']
        self.html_url = issue['html_url']
        self.issue_number = issue['number']

    def make_from_timeline(self, d):
        self.action = d['payload_action']
        self.html_url = d['url']
        self.issue_number = int(d['payload_number'])

@register_event
class PushEvent(Event):
    def make_from_event(self, d):
        p = d['payload']
        self.ref = p['ref']
        self.head = p['head']
        self.before = p['before']
        self.commit_count = p['size']
        self.distinct_commit_count = p['distinct_size']

    def make_from_timeline(self, d):
        # The "commit" here seems to be a random commit in the push.
        # Only one is listed, and it's not the first nor the last. ಠ_๏
        self.ref = d['payload_ref']
        self.head = d['payload_head']
        self.before = None
        self.commit_count = None
        self.distinct_count = None

@register_event
class CommitCommentEvent(Event):
    def make_from_event(self, raw_event):
        comment = raw_event['payload']['comment']
        self.path = comment['path'] # to file, if applicable
        self.body = comment['body']
        self.comment_id = comment['id']
        self.commit_id = comment['commit_id']
        self.html_url = comment['html_url']

    def _url_from_timeline(self):
        template = "https://github.com/{e.repo}/commit/{e.commit_id}#commitcomment-{e.comment_id}"
        return template.format(e=self)

    def make_from_timeline(self, d):
        self.path = d['payload_comment_path']
        self.body = d['payload_comment_body']
        self.comment_id = d['payload_comment_id']
        self.commit_id = d['payload_commit']
        self.html_url = self._url_from_timeline()


@register_event
class ReleaseEvent(Event):
    def make_from_event(self, raw_event):
        self.action = raw_event['payload']['action']
        r = raw_event['payload']['release']
        self.tag_name = r['tag_name']
        self.download_url = r['html_url']

    def make_from_timeline(self, raw_event):
        self.action = raw_event['payload_action']
        self.download_url = urllib.parse.urldefrag(raw_event['url']).url
        self.tag_name = os.path.basename(self.download_url)

@register_event
class PublicEvent(Event):
    def make_from_event(self, d):
        pass

    def make_from_timeline(self, d):
        pass

@register_event
class MemberEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.target_user = p['member']['login']
        self.target_action = p['action']

    def make_from_timeline(self, raw_event):
        self.target_user = raw_event['payload_member_login']
        self.target_action = raw_event['payload_action']

@register_event
class IssueCommentEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.action = p['action']
        self.issue_number = p['issue']['number']
        self.issue_url = p['issue']['html_url']
        self.comment_url = p['comment']['html_url']
        self.comment_id = p['comment']['id']
        self.comment_body = p['comment']['body']


    def make_from_timeline(self, raw_event):
        self.issue_url = urllib.parse.urldefrag(raw_event['url']).url
        self.action=raw_event.get('payload_action', '') # closed, open, created, null

        # this timeline is so awful. ಠ_ಠ
        try:
            self.issue_number = int(os.path.basename(self.issue_url))
        except:
            self.issue_number = ''

        self.comment_url = raw_event['url']
        self.comment_id = int(raw_event['payload_comment_id'])
        self.comment_body = raw_event['payload_comment_body']



def log(*args):
    print(*args, file=sys.stderr)

def make_user_event_filter(login):
    def _filter(raw_event):
        return raw_event['actor']['login'] == login
    return _filter

def make_event_type_filter(event_type):
    def _filter(raw_event):
        return raw_event['type'] == event_type
    return _filter

class EventProcessor(object):
    def __init__(self):
        self.count = 0

    def process_event(self, raw_event, source_fmt):
        event = Event.from_raw(raw_event, source_fmt)
        if event:
            self.count += 1
            if self.count % 10000 == 0:
                log("processed: {}".format(self.count))
            #print(json.dumps(raw_event).strip())
            #print('---')
            print(json.dumps(event.__dict__).strip())

class EventSource(object):
    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _filenames(self, base, pattern):
        return glob.iglob(os.path.join(base, pattern))

    def _open_file(self, path, mode):
        log('loading events from: {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')

class EventEventSource(EventSource):
    """
    Iterate over every event
    The class name seems idiotic, but the Event data can either come from the
    "Event API" or the "Timeline API" depending on the year.
    """

    def __iter__(self):
        # Iterator for source files:
        archive_filenames = os.path.join(self.path, '*.json.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                    openhook=self._open_file)
        # TODO make sure them things get closed ^^

        events = (json.loads(line) for line in lines)
        return (event for event in events
                if self.predicate(event))

class TimelineEventSource(EventSource):
    """
    Iterate over every event from 2011-2014 (when gitarchive used the Timeline API)
    """

    def __iter__(self):
        archive_filenames = os.path.join(self.path, '*.csv.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                    openhook=self._open_file)
        reader = csv.DictReader(lines)
        return (line for line in reader
                if self.predicate(line))


def main():
    predicate = None
    if len(sys.argv) > 1:
        predicate = make_event_type_filter(sys.argv[1])
    processor = EventProcessor()
    source = EventEventSource(GITHUB_ARCHIVE_EVENT_PATH, predicate)
    for raw_event in source:
        processor.process_event(raw_event, 'event')
        break
    source = TimelineEventSource(GITHUB_ARCHIVE_TIMELINE_PATH, predicate)
    for raw_event in source:
        processor.process_event(raw_event, 'timeline')
        break

if __name__=='__main__':
    main()
