#!/usr/bin/env python3
# Works only for archives from 2015-01-01 -> Present
import os
import os.path
import sys
import json
import itertools
import gzip
import glob
import fileinput
from pprint import pprint

ARCHIVE_PATH = os.getenv("GITHUB_ARCHIVE") or os.path.expanduser('~/github-archive')

class Event(object):
    types = dict()

    def __init__(self, raw_event):
        #self.__dict__ = raw_event
        # Common to all events
        self.type = raw_event['type']
        self.id = raw_event['id']
        self.created_at = raw_event['created_at']

        # Frequent on events
        if 'actor' in raw_event:
            self.user = raw_event['actor']['login']
            self._user_lower = self.user.lower()
        if 'repo' in raw_event:
            self.repo_name = raw_event['repo']['name']
            self._repo_lower = self.repo.lower()
        if 'org' in raw_event:
            self.org = raw_event['org']['login']
            self._org_lower = self.org.lower()


        self.make(raw_event)


    def make(self, raw_event):
        pass

    @classmethod
    def register_event(cls, event_cls):
        cls.types[event_cls.__name__] = event_cls
        return event_cls

    @classmethod
    def from_raw(cls, raw_event):
        """
        Factory method to create appropriate event instance from raw JSON data
        """
        subclass = cls.types.get(raw_event['type'], None)
        if subclass is None:
            return None
        return subclass(raw_event)


register_event = Event.register_event

@register_event
class GollumEvent(Event):
    def make(self, raw_event):
        pass

@register_event
class IssuesEvent(Event):
    pass

@register_event
class PushEvent(Event):
    pass

@register_event
class CommitCommentEvent(Event):
    pass

@register_event
class ReleaseEvent(Event):
    pass

@register_event
class PublicEvent(Event):
    pass

@register_event
class MemberEvent(Event):
    pass

@register_event
class IssueCommentEvent(Event):
    pass

def jsonp(j):
    print(json.dumps(j, sort_keys=True, indent=4))

def log(*args):
    print(*args, file=sys.stderr)

def make_user_event_filter(login):
    """
    Make a predicate closure for user filtering
    """
    def _filter(raw_event):
        return raw_event['actor']['login'] == login
    return _filter

def make_event_type_filter(event_type):
    def _filter(raw_event):
        return raw_event['type'] == event_type
    return _filter

class EventProcessor(object):
    def __init__(self):
        self.count = 0

    def process_event(self, raw_event):
        event = Event.from_raw(raw_event)
        if event:
            self.count += 1
            if self.count % 10000 == 0:
                log("processed: {}".format(self.count))
            # i know this is dumb, i should have saved the *really* raw_event(json)
            print(json.dumps(raw_event).strip())

class EventSource(object):
    """
    Iterate over every event
    """

    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _open_file(self, path, mode):
        log('Processing {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')


    def __iter__(self):
        # Iterator for source files:
        archive_filenames = os.path.join(self.path, '*.json.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                openhook=self._open_file)
        # TODO make sure them things get closed ^^

        events = (json.loads(line) for line in lines)
        return (event for event in events
                if self.predicate(event))


if __name__=='__main__':
    predicate = None
    if len(sys.argv) == 2:
        predicate = make_user_event_filter(sys.argv[1])
    # predicate = make_event_type_filter('GollumEvent')
    processor = EventProcessor()
    predicate = bool
    source = EventSource(ARCHIVE_PATH, predicate)
    for raw_event in source:
        processor.process_event(raw_event)
