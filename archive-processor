#!/usr/bin/env python3
# Works only for archives from 2015-01-01 -> Present
import os
import os.path
import sys
from datetime import datetime
import csv
import json
import itertools
import gzip
import glob
import fileinput
from pprint import pprint

GITHUB_ARCHIVE_EVENT_PATH = os.getenv("GITHUB_ARCHIVE_EVENT") or os.path.expanduser('~/github-archive')
GITHUB_ARCHIVE_TIMELINE_PATH = os.getenv("GITHUB_ARCHIVE_TIMELINE") or os.path.expanduser('~/github-archive-timeline')


class Event(object):
    types = dict()

    def __init__(self, raw_event, source_fmt):
        makers = {
            'event': (self.make_common_from_event, self.make_from_event),
            'timeline': (self.make_common_from_timeline, self.make_from_timeline)
        }
        maker = makers.get(source_fmt, None)
        if maker is None:
            raise "source_fmt should either be 'event' (json) or 'timeline' (csv)"
        for m in maker:
            m(raw_event)

    def make_common_from_event(self, raw_event):
        self.type = raw_event['type']
        self.id = raw_event['id']
        self.created_at = raw_event['created_at']

        if 'actor' in raw_event:
            self.user = raw_event['actor']['login']
            self._user_lower = self.user.lower()
        if 'repo' in raw_event:
            self.repo = raw_event['repo']['name']
            self._repo_lower = self.repo.lower()
        if 'org' in raw_event:
            self.org = raw_event['org']['login']
            self._org_lower = self.org.lower()

    def make_common_from_timeline(self, raw_event):
        datetime.strptime('2014-06-14 06:13:26', '%Y-%m-%d %H:%M:%S')
        pass


    def make_from_event(self, raw_event):
        """
        From new API, natively JSON (on/after 2015-01-01)
        """

    def make_from_timeline(self, row):
        """
        From old API (before 2015-01-01)
        """

    @classmethod
    def register_event(cls, event_cls):
        cls.types[event_cls.__name__] = event_cls
        return event_cls

    @classmethod
    def from_raw(cls, raw_event, source_fmt):
        """
        Factory method to create appropriate event instance from raw JSON data
        """
        subclass = cls.types.get(raw_event['type'], None)
        if subclass is None:
            return None
        return subclass(raw_event, source_fmt)


register_event = Event.register_event

@register_event
class GollumEvent(Event):
    def make_from_event(self, raw_event):
        self.pages = raw_event['payload']['pages']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class IssuesEvent(Event):
    def make_from_event(self, raw_event):
        self.repo_name = raw_event['repo']['name']
        self.action = raw_event['payload']['action']
        issue = raw_event['payload']['issue']
        self.html_url = issue['html_url']
        self.issue_number = issue['number']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class PushEvent(Event):
    def make_from_event(self, raw_event):
        self.payload = raw_event['payload']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class CommitCommentEvent(Event):
    def make_from_event(self, raw_event):
        comment = raw_event['payload']['comment']
        self.path = comment['path'] # to file, if applicable
        self.html_url = comment['html_url']
        self.line = comment['line']
        self.position = comment['position']
        self.body = comment['body']
        self.commit_id = comment['commit_id']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class ReleaseEvent(Event):
    def make_from_event(self, raw_event):
        self.action = raw_event['payload']['action']
        r = raw_event['payload']['release']
        self.tag_name = r['tag_name']
        self.download_url = r['html_url']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class PublicEvent(Event):
    def make_from_event(self, raw_event):
        pass

    def make_from_timeline(self, raw_event):
        pass

    def __str__(self):
        "{}: {}".format()
        pass

@register_event
class MemberEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.target_user = p['member']['login']
        self.target_action = p['action']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class IssueCommentEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.action = p['action']
        self.issue_number = p['issue']['number']
        self.issue_url = p['issue']['html_url']
        self.comment_url = p['comment']['html_url']
        self.comment_body = p['comment']['body']
        self.comment_id = p['comment']['id']

    def make_from_timeline(self, raw_event):
        pass

def log(*args):
    print(*args, file=sys.stderr)

def make_user_event_filter(login):
    def _filter(raw_event):
        return raw_event['actor']['login'] == login
    return _filter

def make_event_type_filter(event_type):
    def _filter(raw_event):
        return raw_event['type'] == event_type
    return _filter

class EventProcessor(object):
    def __init__(self):
        self.count = 0

    def process_event(self, raw_event, source_fmt):
        event = Event.from_raw(raw_event, source_fmt)
        if event:
            self.count += 1
            if self.count % 10000 == 0:
                log("processed: {}".format(self.count))
            #print(json.dumps(raw_event).strip())
            #print('---')
            #print(json.dumps(event.__dict__).strip())
            #sys.exit(1)

class EventEventSource(object):
    """
    Iterate over every event
    The class name seems idiotic, but the Event data can either come from the
    "Event API" or the "Timeline API" depending on the year.
    """

    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _open_file(self, path, mode):
        log('Processing {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')

    def __iter__(self):
        # Iterator for source files:
        archive_filenames = os.path.join(self.path, '*.json.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                openhook=self._open_file)
        # TODO make sure them things get closed ^^

        events = (json.loads(line) for line in lines)
        return (event for event in events
                if self.predicate(event))

class TimelineEventSource(object):
    """
    Iterate over every event from 2011-2014 (when gitarchive used the Timeline API)
    """

    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _open_file(self, path, mode):
        log('Processing {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')

    def __iter__(self):
        archive_filenames = os.path.join(self.path, '*.csv.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                    openhook=self._open_file)
        reader = csv.DictReader(lines)
        return reader


def main():
    predicate = None
    if len(sys.argv) > 1:
        predicate = make_event_type_filter(sys.argv[1])
    processor = EventProcessor()
    #source = EventEventSource(GITHUB_ARCHIVE_EVENT_PATH, predicate)
    source = TimelineEventSource(GITHUB_ARCHIVE_TIMELINE_PATH, predicate)
    for raw_event in source:
        processor.process_event(raw_event, 'timeline')

if __name__=='__main__':
    main()
