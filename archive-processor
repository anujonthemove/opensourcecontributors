#!/usr/bin/env python3
# Works only for archives from 2015-01-01 -> Present
import os
import os.path
import sys
import csv
import json
import itertools
import gzip
import glob
import fileinput
import urllib.parse
import dateutil
from pprint import pprint
from datetime import datetime

GITHUB_ARCHIVE_EVENT_PATH = os.getenv("GITHUB_ARCHIVE_EVENT") or os.path.expanduser('~/github-archive')
GITHUB_ARCHIVE_TIMELINE_PATH = os.getenv("GITHUB_ARCHIVE_TIMELINE") or os.path.expanduser('~/github-archive-timeline')


class Event(object):
    types = dict()

    def __init__(self, raw_event, source_fmt):
        makers = {
            'event': (self.make_common_from_event, self.make_from_event),
            'timeline': (self.make_common_from_timeline, self.make_from_timeline)
        }
        maker = makers.get(source_fmt, None)
        if maker is None:
            raise "source_fmt should either be 'event' (json) or 'timeline' (csv)"
        for m in maker:
            m(raw_event)

    def make_common_from_event(self, raw_event):
        self.type = raw_event['type']
        self.id = raw_event['id']
        self.created_at = raw_event['created_at']

        if 'actor' in raw_event:
            self.user = raw_event['actor']['login']
            self._user_lower = self.user.lower()
        if 'repo' in raw_event:
            self.repo = raw_event['repo']['name']
            self._repo_lower = self.repo.lower()
        if 'org' in raw_event:
            self.org = raw_event['org']['login']
            self._org_lower = self.org.lower()

    def make_common_from_timeline(self, raw_event):
        self.type = raw_event['type']
        self.created_at = datetime.strptime(raw_event['created_at'],
                                            '%Y-%m-%d %H:%M:%S').isoformat()
        if raw_event['actor']:
            self.user = raw_event['actor']
            self._user_lower = self.user.lower()
        if raw_event['repository_name'] and raw_event['repository_owner']:
            self.repo = "{}/{}".format(raw_event['repository_name'],
                                       raw_event['repository_owner'])
            self._repo_lower = self.repo.lower()
        if raw_event['repository_organization']:
            self.org = raw_event['repository_organization']
            self._org_lower = self.org.lower()

    def make_from_event(self, raw_event):
        """
        From new API, natively JSON (on/after 2015-01-01)
        """

    def make_from_timeline(self, row):
        """
        From old API (before 2015-01-01)
        """

    @classmethod
    def register_event(cls, event_cls):
        cls.types[event_cls.__name__] = event_cls
        return event_cls

    @classmethod
    def from_raw(cls, raw_event, source_fmt):
        """
        Factory method to create appropriate event instance from raw JSON data
        """
        subclass = cls.types.get(raw_event['type'], None)
        if subclass is None:
            return None
        return subclass(raw_event, source_fmt)


register_event = Event.register_event

@register_event
class GollumEvent(Event):
    def make_from_event(self, raw_event):
        self.pages = raw_event['payload']['pages']

    def make_from_timeline(self, d):
        self.pages = [{
            'html_url': d["payload_page_html_url"],
            'summary': d["payload_page_summary"],
            'name': d["payload_page_page_name"],
            'action': d["payload_page_action"],
            'title': d["payload_page_title"],
            'sha': d["payload_page_sha"]
        }]


@register_event
class IssuesEvent(Event):
    def make_from_event(self, raw_event):
        self.action = raw_event['payload']['action']
        issue = raw_event['payload']['issue']
        self.html_url = issue['html_url']
        self.issue_number = issue['number']

    def make_from_timeline(self, d):
        self.action = d['payload_action']
        self.html_url = d['url']
        self.issue_number = d['payload_number']

@register_event
class PushEvent(Event):
    def make_from_event(self, raw_event):
        self.payload = raw_event['payload']

    def make_from_timeline(self, raw_event):
        pass

@register_event
class CommitCommentEvent(Event):
    def make_from_event(self, raw_event):
        comment = raw_event['payload']['comment']
        self.path = comment['path'] # to file, if applicable
        self.html_url = comment['html_url']
        self.line = comment['line']
        self.position = comment['position']
        self.body = comment['body']
        self.commit_id = comment['commit_id']

    def make_from_timeline(self, d):
        self.path = d['payload_comment_path']
        self.html_url = d['url']
        self.line = d['payload_commit_position']
        self.position = d['payload_commit_position']
        self.body = d['payload_comment_body']
        self.commit_id = d['payload_commit']

@register_event
class ReleaseEvent(Event):
    def make_from_event(self, raw_event):
        self.action = raw_event['payload']['action']
        r = raw_event['payload']['release']
        self.tag_name = r['tag_name']
        self.download_url = r['html_url']

    def make_from_timeline(self, raw_event):
        self.action = raw_event['payload_action']
        self.download_url = urllib.parse.urldefrag(raw_event['url']).url
        self.tag_name = os.path.basename(self.download_url)

@register_event
class PublicEvent(Event):
    def make_from_event(self, raw_event):
        pass

    def make_from_timeline(self, raw_event):
        pass

    def __str__(self):
        "{}: {}".format()
        pass

@register_event
class MemberEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.target_user = p['member']['login']
        self.target_action = p['action']

    def make_from_timeline(self, raw_event):
        self.target_user = raw_event['payload_member_login']
        self.target_action = raw_event['payload_target_action']

@register_event
class IssueCommentEvent(Event):
    def make_from_event(self, raw_event):
        p = raw_event['payload']
        self.action = p['action']
        self.issue_number = p['issue']['number']
        self.issue_url = p['issue']['html_url']
        self.comment_id = p['comment']['id']
        self.comment_url = p['comment']['html_url']
        self.comment_body = p['comment']['body']


    def make_from_timeline(self, raw_event):
        self.issue_url = urllib.parse.urldefrag(raw_event['url']).url
        self.action=raw_event.get('payload_action', '') # closed, open, created, null

        # this timeline is so awful. ಠ_ಠ
        try:
            self.issue_number = int(os.path.basename(self.issue_url))
        except:
            self.issue_number = ''

        self.comment_url = raw_event['url']
        self.comment_id = raw_event['payload_comment_id']
        self.comment_body = raw_event['payload_comment_body']



def log(*args):
    print(*args, file=sys.stderr)

def make_user_event_filter(login):
    def _filter(raw_event):
        return raw_event['actor']['login'] == login
    return _filter

def make_event_type_filter(event_type):
    def _filter(raw_event):
        return raw_event['type'] == event_type
    return _filter

class EventProcessor(object):
    def __init__(self):
        self.count = 0

    def process_event(self, raw_event, source_fmt):
        event = Event.from_raw(raw_event, source_fmt)
        if event:
            self.count += 1
            if self.count % 10000 == 0:
                log("processed: {}".format(self.count))
            #print(json.dumps(raw_event).strip())
            #print('---')
            #print(json.dumps(event.__dict__).strip())
            #sys.exit(1)

class EventEventSource(object):
    """
    Iterate over every event
    The class name seems idiotic, but the Event data can either come from the
    "Event API" or the "Timeline API" depending on the year.
    """

    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _open_file(self, path, mode):
        log('Processing {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')

    def __iter__(self):
        # Iterator for source files:
        archive_filenames = os.path.join(self.path, '*.json.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                openhook=self._open_file)
        # TODO make sure them things get closed ^^

        events = (json.loads(line) for line in lines)
        return (event for event in events
                if self.predicate(event))

class TimelineEventSource(object):
    """
    Iterate over every event from 2011-2014 (when gitarchive used the Timeline API)
    """

    def __init__(self, path, predicate=bool):
        self.path = path
        self.predicate = predicate

    def _open_file(self, path, mode):
        log('Processing {}'.format(path))
        sys.stdout.flush()
        return gzip.open(path,'rt')

    def __iter__(self):
        archive_filenames = os.path.join(self.path, '*.csv.gz')
        archive_filenames = glob.iglob(archive_filenames)

        # Iterator for lines of these source files
        lines = fileinput.FileInput(files=archive_filenames,
                                    openhook=self._open_file)
        reader = csv.DictReader(lines)
        return reader


def main():
    predicate = None
    if len(sys.argv) > 1:
        predicate = make_event_type_filter(sys.argv[1])
    processor = EventProcessor()
    #source = EventEventSource(GITHUB_ARCHIVE_EVENT_PATH, predicate)
    source = TimelineEventSource(GITHUB_ARCHIVE_TIMELINE_PATH, predicate)
    for raw_event in source:
        processor.process_event(raw_event, 'timeline')

if __name__=='__main__':
    main()
